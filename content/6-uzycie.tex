


\section{Własna gra - Snake}

\textbf{Snake} jest popularnym konceptem prostej gry komputerowej, gdzie gracz ma za zadanie manewrować poruszającą się linią w taki sposób, aby nie kolidowała ze sobą lub, dodatkowo ściankami planszy, w między czasie zbierając punkty w postaci. Linia ma za zadanie reprezentować ciało węża, który pełza, a punkty reprezentowane są w postaci owocu, lub prostej grupki pikseli.
Odmiana użyta w celu testowania sieci neuronowej została na pisana w języku \textbf{Python}, przy użyciu paczki \textbf{PyGame}, która posłuży do reprezentacji graficznej postępowania sztucznej inteligencji, oraz samej rozgrywki.
Wąż został przestawiony w postaci linii składającej się z pojedynczych zielonych kwadratów. Wąż zaczyna z trzema zielonymi kwadratami, każdy dodatkowo zdobyty punkt podłuża węża o jeden kwadrat. Punkty możliwe do zdobycia są reprezentowany w postaci czerwonych kwadratów.

\begin{figure}[h!]
    \centering
    \mediumimage{img/snake1.png}
    \caption{Gra Snake}
    \label{img:snake_game}
\end{figure}

\clearpage

Większość mechaniki gry została zaimplementowana w klasie \lcode{SnakeGame}, która odpowiada za mechanikę gry oraz przechowywanie jej stanu. Znajdują się w niej między innymi mechaniki odpowiedzialne za wykrywanie zderzeń, poruszanie się węża, sterowanie wężem, czy losowanie miejsca pojawienia się następnych punktów. Dodatkowo zaimplementowane zostały klasy enumeratorowe, takie jak \lcode{Direction} i \lcode{GamePoint} w celu zwiększenia czytelności kodu:

\begin{onepage}
    \begin{lstlisting}[
        caption={Instalacja paczki używając narzędzia \textbf{pip}},
        label=code:pip_install_gai,
        language={Python},
        numbers=left,
        ]
        import numpy as np
        import torch
        from sgai.agent.trainer import Trainer
        
        from snake import Direction, GamePoint, SnakeGame
    \end{lstlisting}
\end{onepage}



Następnie definiujemy potrzebny interfejs \lcode{Trainer}, aby paczka \lcode{sgai} umiała się komunikować z grą. Zaczynami od definicji klasy i jej konstruktora. W tym przykładzie wielkość warstwy ukrytej pozostawiamy nie zmienioną ponieważ podstawowa w pełni wystarczy do poziomu skomplikowania przygotowanej gry:

\begin{onepage}
    \begin{lstlisting}[
        caption={Instalacja paczki używając narzędzia \textbf{pip}},
    label=code:pip_install_gai,
    language={Python},
    numbers=left
]
class MyTrainer(Trainer):
    def __init__(self, game, input_size: int, output_size: int):
        super().__init__(game, input_size, output_size)
    \end{lstlisting}
\end{onepage}

Następnie definiujemy dwie funkcje \lcode{get_state()}, oraz \lcode{perform_action()}. Są one interfejsem pomiędzy paczką \lcode{sgai}, a kodem gry, dlatego to użytkownik paczki musi je zaimplementować, ponieważ paczka nie ma możliwości posiadania wiedzy na temat własności działania kodu gry na, której będzie szkolić sieć neuronową. Na samym początku definiujemy stan gry, pobierając konkretne elementy rozgrywki takie jak pozycja węża, pozycja nagrody itp.:

\begin{onepage}
    \begin{lstlisting}[
        caption={Instalacja paczki używając narzędzia \textbf{pip}},
    label=code:pip_install_gai,
    language={Python},
    numbers=left
]
    def get_state(self) -> np.ndarray:
        head = self.game.snake[0]
        point_left = GamePoint(head.x - 20, head.y)
        point_right = GamePoint(head.x + 20, head.y)
        point_up = GamePoint(head.x, head.y - 20)
        point_down = GamePoint(head.x, head.y + 20)

        left_direction = self.game.direction == Direction.LEFT
        right_direction = self.game.direction == Direction.RIGHT
        up_direction = self.game.direction == Direction.UP
        down_direction = self.game.direction == Direction.DOWN
    \end{lstlisting}
\end{onepage}

W tym przykładzie zebranych będzie łącznie $11$ parametrów opisujących stan gry, które następnie zostaną przekazane sieci neuronowej jako wejście. Gdzie każda z wartości może być jedynie $0$, lub $1$, $0$ oznaczające \lcode{False}, a $1$ \lcode{True}:

\begin{itemize}
    \item Czy jakieś niebezpieczeństwo znajduje się naprzeciwko?
    \item Czy niebezpieczeństwo znajduje się po prawej?
    \item Czy niebezpieczeństwo znajduje się po lewej?
    \item Czy wąż porusza się w lewo?
    \item Czy wąż porusza się w prawo?
    \item Czy wąż porusza się w górę?
    \item Czy wąż porusza się w dół?
    \item Czy jedzenie znajduje się po lewej?
    \item Czy jedzenie znajduje się po prawej?
    \item Czy jedzenie znajduje się nad wężem?
    \item Czy jedzenie znajduje się pod wężem?
\end{itemize}


\begin{onepage}
    \begin{lstlisting}[
    caption={Instalacja paczki używając narzędzia \textbf{pip}},
    label=code:pip_install_gai,
    language={Python},
    numbers=left
]
        state = [
            # Danger straight
            (right_direction and self.game.is_collision(point_right))
            or (left_direction and self.game.is_collision(point_left))
            or (up_direction and self.game.is_collision(point_up))
            or (down_direction and self.game.is_collision(point_down)),
            # Danger right
            (up_direction and self.game.is_collision(point_right))
            or (down_direction and self.game.is_collision(point_left))
            or (left_direction and self.game.is_collision(point_up))
            or (right_direction and self.game.is_collision(point_down)),
            # Danger left
            (down_direction and self.game.is_collision(point_right))
            or (up_direction and self.game.is_collision(point_left))
            or (right_direction and self.game.is_collision(point_up))
            or (left_direction and self.game.is_collision(point_down)),
            # Move direction
            left_direction,
            right_direction,
            up_direction,
            down_direction,
            # Food location
            self.game.food.x < self.game.head.x,  # Food left
            self.game.food.x > self.game.head.x,  # Food right
            self.game.food.y < self.game.head.y,  # Food up
            self.game.food.y > self.game.head.y,  # Food down
        ]

        return np.array(state, dtype=int)
    \end{lstlisting}
\end{onepage}


\begin{onepage}
    \begin{lstlisting}[
    caption={Instalacja paczki używając narzędzia \textbf{pip}},
    label=code:pip_install_gai,
    language={Python},
    numbers=none
]
    def perform_action(self, state) -> Tuple[int, bool, int]:
        # Get random moves: tradeoff exploration / exploitation
        self.epsilon = 80 - self.number_of_games
        final_move = [0, 0, 0]
        if random.randint(0, 200) < self.epsilon:
            move = random.randint(0, 2)
            final_move[move] = 1
        else:
            state0 = torch.tensor(state, dtype=torch.float)
            prediction = self.model(state0)
            move = torch.argmax(prediction).item()
            final_move[move] = 1

        return final_move

    \end{lstlisting}
\end{onepage}

\begin{figure}[h]
    \centering
    \bigimage{img/ai_graph2.png}
    \caption{Wykres nauki sieci neuronowej}
    \label{img:ai_graph}
\end{figure}

\subsection{Cudza gra - PyGame Examples}
