% \section{Użyte narzędzia i technologie}



\section{Język Python}
Język \textbf{Python} jest bardzo popularnym, nowoczesnym oraz wysokopoziomowym językiem programowania. Czytając artykuły i inne treści na temat historii \textbf{Python} \cite{HistoriaPythona} \cite{WikiepdiaPythonProgrammingLanauge} dowiadujemy się, że język powstał w 1991 roku. Stworzony przez Guido van Rossum podczas swojej pracy w laboratorium w Centrum Matematyki i Informatyki w Amsterdamie, pierwotnie tworzony był z myślą zastąpienia rozwijanego w latach osiemdziesiątych języka \textbf{ABC}. Samą nazwę język Python nazwę zawdzięcza popularnemu serialowi komediowemu emitowanego przez BBC w latach siedemdziesiątych - ``Latający Cyrk Monty Pythona'', którego Guido był fanem.
Projekt początkowo zakładał stworzenie prostego w użyciu, zwięzłego i wysokopoziomowego języka, głównie na potrzeby pracy w Amsterdamskim laboratorium. Z biegiem czasu \textbf{Python} stał się rozwijanym przez społeczność projektem \textbf{Open Source}, nad którym czuwała organizacja non-profit założona przez Guido von Rossum'a, \textbf{Python Software Foundation}.

\textbf{Python} jest multi-paradygmatowym językiem, gdzie programowanie obiektowe i strukturalne są w pełni wspierane, wiele cech języka wspiera programowanie funkcyjne i aspektowe. Wiele innych paradygmatów jest wspieranych dzięki modularnym rozszerzeniom do języka.
\textbf{Python} w przeciwieństwie do języków statycznie typowanych takich jak \textbf{C}, \textbf{Rust} czy \textbf{TypeScript}, stosuje typowanie dynamiczne, które sprawdza poprawność i bezpieczeństwo typów w programie, dynamicznie, podczas jego egzekucji, w przeciwieństwie do typowania statycznego, gdzie typy sprawdzane są podczas kompilacji kodu. Dodatkowo \textbf{Python} posiada kombinacje zliczania referencji oraz cyklicznego \textbf{Garbage Collector}'a.
Architektura języka \textbf{Python} oferuje wsparcie, dla programowanie funkcyjnego zgodnego z tradycją języka \textbf{List}. Język posiada typowe, dla języków funkcyjnych funkcje takie jak \lcode{filter}, \lcode{map}, \lcode{reduce}, list comprehensions, słowniki oraz generatory. Standardowa biblioteka języka posiada moduły \lcode{itertools} oraz \lcode{functools}, które implementują narzędzia funkcjonalne zapożyczone z języków \textbf{Haskell} oraz \textbf{Standard ML}.

Zamiast polegać na wbudowanej funkcjonalności w jądro języka, \textbf{Python} został zaprojektowany tak, aby być najmożliwiej elastyczny, aby mógł współdziałać z różnymi odrębnymi modułami. Sama kompaktowa modularność sprawiła, że język stał się popularnym sposobem, na dodawanie programowalnego interfejsu to istniejących już aplikacji oraz języków programowania.
\textbf{CPython} jest referencyjną implementacją \textbf{Python}'a, napisaną w \textbf{C}, która spełnia standard \textbf{C89} z niektórymi cechami standardu \textbf{C99}. Jedną z charakterystyk implementacji \textbf{CPython}'a jest to, że zespół odpowiedzialny za rozwój oraz utrzymanie kodu jego interpretera preferuje odrzucanie poprawek do kodu mających na celu marginalną poprawę szybkości i sprawności interpretera w zamian za zachowanie czystości i czytelności kodu źródłowego. Taka długoterminowa postawa umożliwiła powstanie powstanie innych implementacji języka \textbf{Python} opartych o inne rozwiązania, bądź inne języki za pomocą których napisany został sam interpreter. Dzięki różnorodności implementacji \textbf{Python}'a, jego modularności i łatwej rozbudowie o obce rozszerzenia programista może zdecydować się na przeniesienie wrażliwych na czas wykonywania funkcjonalności do odrębnych modułów napisanych w innych językach takich jak \textbf{C}, lub \textbf{Rust}, albo użyć wyspecjalizowanej do tego odmiany samego interpretera takiej jak \textbf{PyPy}, która posiada tak zwany \textbf{JIT}, czyli \textbf{Just-In-Time compiler}, pozwalający na optymalizację kodu na system bądź architekturę docelową danego programu.

Dzięki tak rozbudowanemu środowisku oraz społeczności otaczającej język powstała ogromna biblioteka paczek, dla języka \textbf{Python}, która często podawana za jedną z największych zalet języka. W ten sposób \textbf{Python} stał się swoistym odpowiednikiem \textit{Lingua Franca} wśród programistów. Przez co często dziedziny zajmujące się całkowicie różnymi dziedzinami takimi jak Web Development, Automatyzacja, Bazy Danych, Aplikacje Mobilne, Testowanie Oprogramowania, Analiza Danych oraz Uczenie Maszynowe.



\section{Biblioteka PyTorch}

\textbf{PyTorch} \cite{PyTorchWebSite} jest Open Source'ową biblioteką służącą do uczenia maszynowego. Jest bazowana na bibliotece \textbf{Torch} napisanej w języku \textbf{Lua}. Z powodu niszowości języka \textbf{Lua}, oraz braku modularności i możliwości rozbudowywania o nowe funkcjonalności za pomocą zewnętrznych modułów i paczek, powstał \textbf{PyTorch}, czyli, biblioteka \textbf{Torch}, ale zaimplementowana w języku \textbf{Python}. Dzięki temu \textbf{PyTorch} może korzystać z bardzo rozbudowanego środowiska \textbf{Python}, które oferuje dużą ilość naukowych paczek, między innymi takich jak \textbf{NumPy}.


Jedną z największych zalet biblioteki \textbf{PyTorch} jest możliwość programowanie imperatywnego. Jest to przeciwieństwem do bibliotek takich jak \textbf{TensorFlow} i \textbf{Keras}, które ze względu na poleganie głównie na językach takich jak \textbf{C} i \textbf{C++}, oferują jedynie możliwość programowania symbolicznego. Większość \textbf{Python}'owego kodu jest imperatywne jako, że jest to dynamicznie interpretowany język. W sytuacji symboliczne zachodzi przeciwieństwo, ponieważ zachodzi bardzo wyraźne rozróżnienie pomiędzy zdefiniowaniem grafu komputacyjnego, a jego kompilacją. W przypadku imperatywnym komputacja zachodzi w momencie jej wywołania, nie we wcześniej zoptymalizowanym punkcie w kodzie. Podejście symboliczne pozwala na większą optymalizację, a imperatywne takie jak \textbf{PyTorch} pozwalają na większą swobodność, oraz używanie natywnych cech, funkcjonalności i rozszerzających modułów języka \textbf{Python}.
Drugą największą zaletą biblioteki \textbf{PyTorch} są dynamiczne grafy komputacyjne, które w przeciwieństwie do bibliotek takich jak \textbf{TensorFlow} generują je statycznie przed uruchomieniem programu. \textbf{PyTorch} umie generować i modyfikować je dynamicznie podczas działania programu.

\clearpage

\section{Biblioteka NumPy}
\textbf{NumPy} \cite{WikipediaNumPy} jest Open Source biblioteką stworzoną, dla języka programowania \textbf{Python}, dodaje wsparcie, dla dużych wielowymiarowych tablic i macierzy wraz z dużą kolekcją wysokopoziomowych funkcji matematycznych, które pozwalają operować na wspomnianych macierzach. Poprzednikiem biblioteki \textbf{NumPy} był, \textbf{Numeric}, oryginalnie stworzony przez Jim'a Hugunin'a wraz z kontrybucjami kilku innych developerów. W roku 2005, Travis Oliphant stworzył projekt \textbf{NumPy} włączając w to właściwości oraz funkcjonalności \textbf{Numeric}'a.
\textbf{Python} nie był oryginalnie stworzony do numerycznej komputacji, ale już we wczesnym życiu języka różne towarzystwa naukowe i inżynieryjne wyrażały swoje zainteresowanie językiem.
\textbf{NumPy} adresuje problem powolności języka \textbf{Python} poprzez zapewnienie wielowymiarowych macierzy, funkcji i operacji, które są wydajne obliczeniowo operując na macierzach.

Używanie biblioteki \textbf{NumPy} w \textbf{Python}'ie funkcjonalnością przypomina programowanie w środowisku \textbf{MATLAB}, jako, że oba są interpretowane, mają podobną składnie, oba pozwalają użytkownikowi pisać szybkie i wydaje programy tak długo jak operacje przeprowadzane są na macierzach. W przeciwieństwie do \textbf{MATLAB}'a, \textbf{NumPy} nie oferuje wielkiej ilości dodatkowych narzędzi 



\section{Biblioteka Matplotlib}


\section{PyGame}


\section{Klasy abstrakcyjne}




\paragraph{Ukryty link do spisu treści}
Kliknij na numer strony, a pod nim masz ukryty odnośnik do spisu treści. Bardzo ułatwia skakanie po pdf'ie.

\paragraph{Używasz vscode?}
Zobacz na polecane wtyczki w README.

\paragraph{Jak wydzilić z tesktu}
Jak cokolwiek chcesz oddzielić z tekstu możesz użyć \lcode{onepage[Xmm]}.

\begin{onepage}[1cm]
    \centering
    Alias dolor odit. Velit et ut harum. Quos ullam enim suscipit qui omnis dolorum.
\end{onepage}

Reszta tekstu.
Doloremque voluptas sit mollitia eos ut aut. Qui et distinctio vitae. Possimus et in. Est provident qui sequi est nobis cupiditate magni. Recusandae animi aut non ea autem ipsam dolores hic repellendus.

I chyba nic więcej nie potrzeba. Powodzenia!
