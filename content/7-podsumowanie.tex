Celem pracy było zaprojektowanie oraz stworzenie sieci neuronowej zdolnej do samodzielnej nauki gry w dowolną prostą grę zręcznościową. Cel został w całości zrealizowany. Model sieci neuronowej został oparty o uczenie przez wzmacnianie w połączeniu z Q-learning'iem. Dzięki użyciu abstrakcyjnych klas i funkcji języka Python, udało się stworzyć zgeneralizowany interfejs służący do trenowania sieci neuronowej. Dzięki czemu użytkownik poprawnie definiując odpowiednie funkcje wejścia i wyjścia sieci neuronowej w połączeniu ze stanem oraz oddziaływaniem na grę, jest w stanie trenować sieć neuronową na dowolnej grze.

% Uzylem cookiecuttera do stworzenia templata
% Zrestrukturyzowalem program sieci neuronowej tak aby byl paczka pythonowa
% zbudowalem source distribution paczki
% zarejestrowalem paczke na PyPI
% wrzucilem paczke na PyPI
Użyto narzędzia Cookiecutter do stworzenia szablonu paczki Python'owej. Implementację sieci neuronowej przygotowano w sposób umożliwiający umieszczenie jej wewnątrz paczki języka Python. Z której następnie pomyślnie udało się stworzyć dystrybucję źródłową paczki. Następnie zarejestrowano paczkę na oficjalnym indeksie paczek języka Python, PyPI, i pomyślnie ją tam umieszczono.
% Stworzylem gre w snake'a

Testy zostały wykonane przy pomocy stworzonej na potrzeby projektu gry typu Snake. Pomyślnie zaimplementowano interfejs pomiędzy grą a siecią neuronową z paczki. Podczas testów sieć uzyskała zadowalające wyniki, jak na swoją prostą budowę.

Projekt można nadal rozwijać poprzez ulepszenie generacji struktury sieci neuronowej tak, aby ta była w stanie się dostosować do bardziej skomplikowanych gier. Dodatkową możliwością byłoby ułatwienie implementacji interfejsu pomiędzy grą a siecią tak, aby była ona bardziej przyjazna, dla użytkownika paczki.

% Zainstlaowalem swoja paczke
% Podpialem ja do snake'a
% Trenowalem siec neuronowa na snake'u (no i dziala)

% MOZLIWE ULEPSZENIA
% Większa dowolność w tworzeniu sieci neuronowej
% Automatyczne dopasowywanie struktury sieci neuronowej bazujac na zaimplementowanych interfejsach wejscia i wyjscia

